# coding: utf-8

"""
    Stakeholder engagement API

    This API enables Intelligent Engagement for your Business. iEngage is a platform that combines process, augmented intelligence and rewards to help you intelligently engage customers.

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class CollaborationApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def add_comment_blog(self, blog_id, comment_text, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Comment on posted blog
        Allows the user to give comment on posted Blog. Returns the comment
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_comment_blog(blog_id, comment_text, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int blog_id: blogId (required)
        :param str comment_text: Comment Text (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseComment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_comment_blog_with_http_info(blog_id, comment_text, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.add_comment_blog_with_http_info(blog_id, comment_text, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def add_comment_blog_with_http_info(self, blog_id, comment_text, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Comment on posted blog
        Allows the user to give comment on posted Blog. Returns the comment
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_comment_blog_with_http_info(blog_id, comment_text, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int blog_id: blogId (required)
        :param str comment_text: Comment Text (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseComment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['blog_id', 'comment_text', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_comment_blog" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'blog_id' is set
        if ('blog_id' not in params) or (params['blog_id'] is None):
            raise ValueError("Missing the required parameter `blog_id` when calling `add_comment_blog`")
        # verify the required parameter 'comment_text' is set
        if ('comment_text' not in params) or (params['comment_text'] is None):
            raise ValueError("Missing the required parameter `comment_text` when calling `add_comment_blog`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `add_comment_blog`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `add_comment_blog`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `add_comment_blog`")


        collection_formats = {}

        resource_path = '/collaborations/blogs/{blogId}/comments'.replace('{format}', 'json')
        path_params = {}
        if 'blog_id' in params:
            path_params['blogId'] = params['blog_id']

        query_params = {}

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}
        if 'comment_text' in params:
            form_params.append(('commentText', params['comment_text']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/x-www-form-urlencoded'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseComment',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def add_comment_discussion(self, discussion_id, comment_text, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Comment on discussion
        Allows the user to comment on discussion. Returns the comment
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_comment_discussion(discussion_id, comment_text, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int discussion_id: discussionId (required)
        :param str comment_text: Comment Text (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseComment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.add_comment_discussion_with_http_info(discussion_id, comment_text, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.add_comment_discussion_with_http_info(discussion_id, comment_text, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def add_comment_discussion_with_http_info(self, discussion_id, comment_text, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Comment on discussion
        Allows the user to comment on discussion. Returns the comment
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.add_comment_discussion_with_http_info(discussion_id, comment_text, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int discussion_id: discussionId (required)
        :param str comment_text: Comment Text (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseComment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['discussion_id', 'comment_text', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_comment_discussion" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'discussion_id' is set
        if ('discussion_id' not in params) or (params['discussion_id'] is None):
            raise ValueError("Missing the required parameter `discussion_id` when calling `add_comment_discussion`")
        # verify the required parameter 'comment_text' is set
        if ('comment_text' not in params) or (params['comment_text'] is None):
            raise ValueError("Missing the required parameter `comment_text` when calling `add_comment_discussion`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `add_comment_discussion`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `add_comment_discussion`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `add_comment_discussion`")


        collection_formats = {}

        resource_path = '/collaborations/discussions/{discussionId}/comments'.replace('{format}', 'json')
        path_params = {}
        if 'discussion_id' in params:
            path_params['discussionId'] = params['discussion_id']

        query_params = {}

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}
        if 'comment_text' in params:
            form_params.append(('commentText', params['comment_text']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/x-www-form-urlencoded'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseComment',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_blog(self, blog_id, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Delete blog
        Allows the user to delete blog. Returns the deleted blog
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_blog(blog_id, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int blog_id: blog Id (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseBlog
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_blog_with_http_info(blog_id, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.delete_blog_with_http_info(blog_id, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def delete_blog_with_http_info(self, blog_id, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Delete blog
        Allows the user to delete blog. Returns the deleted blog
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_blog_with_http_info(blog_id, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int blog_id: blog Id (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseBlog
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['blog_id', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_blog" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'blog_id' is set
        if ('blog_id' not in params) or (params['blog_id'] is None):
            raise ValueError("Missing the required parameter `blog_id` when calling `delete_blog`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `delete_blog`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `delete_blog`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `delete_blog`")


        collection_formats = {}

        resource_path = '/collaborations/blogs/{blogId}'.replace('{format}', 'json')
        path_params = {}
        if 'blog_id' in params:
            path_params['blogId'] = params['blog_id']

        query_params = {}

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/x-www-form-urlencoded'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseBlog',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_blog_comment(self, comment_id, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Delete blog comment
        Allows the user to delete blog comment.  Returns the deleted blog comment
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_blog_comment(comment_id, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int comment_id: comment Id (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseComment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_blog_comment_with_http_info(comment_id, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.delete_blog_comment_with_http_info(comment_id, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def delete_blog_comment_with_http_info(self, comment_id, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Delete blog comment
        Allows the user to delete blog comment.  Returns the deleted blog comment
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_blog_comment_with_http_info(comment_id, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int comment_id: comment Id (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseComment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['comment_id', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_blog_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'comment_id' is set
        if ('comment_id' not in params) or (params['comment_id'] is None):
            raise ValueError("Missing the required parameter `comment_id` when calling `delete_blog_comment`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `delete_blog_comment`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `delete_blog_comment`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `delete_blog_comment`")


        collection_formats = {}

        resource_path = '/collaborations/blogs/comments/{commentId}'.replace('{format}', 'json')
        path_params = {}
        if 'comment_id' in params:
            path_params['commentId'] = params['comment_id']

        query_params = {}

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/x-www-form-urlencoded'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseComment',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_discussion(self, discussion_id, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Delete discussion
        Allows the user to delete discussion. Returns the deleted discussion
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_discussion(discussion_id, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int discussion_id: discussion Id (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseDiscussion
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_discussion_with_http_info(discussion_id, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.delete_discussion_with_http_info(discussion_id, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def delete_discussion_with_http_info(self, discussion_id, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Delete discussion
        Allows the user to delete discussion. Returns the deleted discussion
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_discussion_with_http_info(discussion_id, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int discussion_id: discussion Id (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseDiscussion
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['discussion_id', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_discussion" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'discussion_id' is set
        if ('discussion_id' not in params) or (params['discussion_id'] is None):
            raise ValueError("Missing the required parameter `discussion_id` when calling `delete_discussion`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `delete_discussion`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `delete_discussion`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `delete_discussion`")


        collection_formats = {}

        resource_path = '/collaborations/discussions/{discussionId}'.replace('{format}', 'json')
        path_params = {}
        if 'discussion_id' in params:
            path_params['discussionId'] = params['discussion_id']

        query_params = {}

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/x-www-form-urlencoded'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseDiscussion',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def delete_discussion_comment(self, comment_id, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Delete discussion comment
        Allows the user to delete discussion comment. Returns the deleted discussion comment
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_discussion_comment(comment_id, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int comment_id: comment Id (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseComment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.delete_discussion_comment_with_http_info(comment_id, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.delete_discussion_comment_with_http_info(comment_id, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def delete_discussion_comment_with_http_info(self, comment_id, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Delete discussion comment
        Allows the user to delete discussion comment. Returns the deleted discussion comment
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.delete_discussion_comment_with_http_info(comment_id, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int comment_id: comment Id (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseComment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['comment_id', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_discussion_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'comment_id' is set
        if ('comment_id' not in params) or (params['comment_id'] is None):
            raise ValueError("Missing the required parameter `comment_id` when calling `delete_discussion_comment`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `delete_discussion_comment`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `delete_discussion_comment`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `delete_discussion_comment`")


        collection_formats = {}

        resource_path = '/collaborations/discussions/comments/{commentId}'.replace('{format}', 'json')
        path_params = {}
        if 'comment_id' in params:
            path_params['commentId'] = params['comment_id']

        query_params = {}

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/x-www-form-urlencoded'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseComment',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_blog_comments(self, blog_id, start, end, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Get list of comments on blog
        Returns the list of comments on blog
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_blog_comments(blog_id, start, end, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int blog_id: blogId (required)
        :param int start: start, initial value start from 0 (required)
        :param int end: end (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseCommentList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_blog_comments_with_http_info(blog_id, start, end, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.get_blog_comments_with_http_info(blog_id, start, end, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def get_blog_comments_with_http_info(self, blog_id, start, end, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Get list of comments on blog
        Returns the list of comments on blog
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_blog_comments_with_http_info(blog_id, start, end, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int blog_id: blogId (required)
        :param int start: start, initial value start from 0 (required)
        :param int end: end (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseCommentList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['blog_id', 'start', 'end', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_blog_comments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'blog_id' is set
        if ('blog_id' not in params) or (params['blog_id'] is None):
            raise ValueError("Missing the required parameter `blog_id` when calling `get_blog_comments`")
        # verify the required parameter 'start' is set
        if ('start' not in params) or (params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `get_blog_comments`")
        # verify the required parameter 'end' is set
        if ('end' not in params) or (params['end'] is None):
            raise ValueError("Missing the required parameter `end` when calling `get_blog_comments`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `get_blog_comments`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `get_blog_comments`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `get_blog_comments`")


        collection_formats = {}

        resource_path = '/collaborations/blogs/{blogId}/comments'.replace('{format}', 'json')
        path_params = {}
        if 'blog_id' in params:
            path_params['blogId'] = params['blog_id']

        query_params = {}
        if 'start' in params:
            query_params['start'] = params['start']
        if 'end' in params:
            query_params['end'] = params['end']

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseCommentList',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_blogs(self, organization_id, start, end, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Get list of blogs
        Returns the list of blogs
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_blogs(organization_id, start, end, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int organization_id: organizationId (required)
        :param int start: start, initial value start from 0 (required)
        :param int end: end (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :param str fields: Filter fields in result list<br/> <b>A) Default values -</b> <br/>1)blogId<br/>2)blogTitle<br/>3)blogDescription<br/>4)createdDate<br/><b>A )Available values-</b><br/>1)blogId<br/>2)blogTitle<br/>3)blogDescription<br/>4)createdDate<br/>5)user<br/>6)sentiment</br>7)entity
        :return: VerveResponseBlogList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_blogs_with_http_info(organization_id, start, end, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.get_blogs_with_http_info(organization_id, start, end, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def get_blogs_with_http_info(self, organization_id, start, end, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Get list of blogs
        Returns the list of blogs
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_blogs_with_http_info(organization_id, start, end, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int organization_id: organizationId (required)
        :param int start: start, initial value start from 0 (required)
        :param int end: end (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :param str fields: Filter fields in result list<br/> <b>A) Default values -</b> <br/>1)blogId<br/>2)blogTitle<br/>3)blogDescription<br/>4)createdDate<br/><b>A )Available values-</b><br/>1)blogId<br/>2)blogTitle<br/>3)blogDescription<br/>4)createdDate<br/>5)user<br/>6)sentiment</br>7)entity
        :return: VerveResponseBlogList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'start', 'end', 'logged_in_user_id', 'access_token', 'client_token', 'fields']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_blogs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `get_blogs`")
        # verify the required parameter 'start' is set
        if ('start' not in params) or (params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `get_blogs`")
        # verify the required parameter 'end' is set
        if ('end' not in params) or (params['end'] is None):
            raise ValueError("Missing the required parameter `end` when calling `get_blogs`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `get_blogs`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `get_blogs`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `get_blogs`")


        collection_formats = {}

        resource_path = '/collaborations/blogs'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'organization_id' in params:
            query_params['organizationId'] = params['organization_id']
        if 'start' in params:
            query_params['start'] = params['start']
        if 'end' in params:
            query_params['end'] = params['end']
        if 'fields' in params:
            query_params['fields'] = params['fields']

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseBlogList',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_discussion_comments(self, discussion_id, start, end, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Get list of comments on discussion
        Returns the list of comments on discussion
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_discussion_comments(discussion_id, start, end, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int discussion_id: discussionId (required)
        :param int start: start, initial value start from 0 (required)
        :param int end: end (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseCommentList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_discussion_comments_with_http_info(discussion_id, start, end, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.get_discussion_comments_with_http_info(discussion_id, start, end, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def get_discussion_comments_with_http_info(self, discussion_id, start, end, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Get list of comments on discussion
        Returns the list of comments on discussion
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_discussion_comments_with_http_info(discussion_id, start, end, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int discussion_id: discussionId (required)
        :param int start: start, initial value start from 0 (required)
        :param int end: end (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseCommentList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['discussion_id', 'start', 'end', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_discussion_comments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'discussion_id' is set
        if ('discussion_id' not in params) or (params['discussion_id'] is None):
            raise ValueError("Missing the required parameter `discussion_id` when calling `get_discussion_comments`")
        # verify the required parameter 'start' is set
        if ('start' not in params) or (params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `get_discussion_comments`")
        # verify the required parameter 'end' is set
        if ('end' not in params) or (params['end'] is None):
            raise ValueError("Missing the required parameter `end` when calling `get_discussion_comments`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `get_discussion_comments`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `get_discussion_comments`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `get_discussion_comments`")


        collection_formats = {}

        resource_path = '/collaborations/discussions/{discussionId}/comments'.replace('{format}', 'json')
        path_params = {}
        if 'discussion_id' in params:
            path_params['discussionId'] = params['discussion_id']

        query_params = {}
        if 'start' in params:
            query_params['start'] = params['start']
        if 'end' in params:
            query_params['end'] = params['end']

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseCommentList',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_discussions(self, organization_id, start, end, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Get list of discussions
        Returns the list of discussions
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_discussions(organization_id, start, end, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int organization_id: organizationId (required)
        :param int start: start, initial value start from 0 (required)
        :param int end: end (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :param str fields: Filter fields in result list<br/> <b>A) Default values -</b> <br/>1)discussionId<br/>2)discussionSubject<br/>3)discussionDescription<br/>4)createdDate<br/><b>A) Available values-</b><br/>1)discussionId<br/>2)discussionSubject<br/>3)discussionDescription<br/>4)createdDate<br/>5)user<br/>6)sentiment</br>7)entity
        :return: VerveResponseDiscussionList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_discussions_with_http_info(organization_id, start, end, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.get_discussions_with_http_info(organization_id, start, end, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def get_discussions_with_http_info(self, organization_id, start, end, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Get list of discussions
        Returns the list of discussions
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_discussions_with_http_info(organization_id, start, end, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int organization_id: organizationId (required)
        :param int start: start, initial value start from 0 (required)
        :param int end: end (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :param str fields: Filter fields in result list<br/> <b>A) Default values -</b> <br/>1)discussionId<br/>2)discussionSubject<br/>3)discussionDescription<br/>4)createdDate<br/><b>A) Available values-</b><br/>1)discussionId<br/>2)discussionSubject<br/>3)discussionDescription<br/>4)createdDate<br/>5)user<br/>6)sentiment</br>7)entity
        :return: VerveResponseDiscussionList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'start', 'end', 'logged_in_user_id', 'access_token', 'client_token', 'fields']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_discussions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `get_discussions`")
        # verify the required parameter 'start' is set
        if ('start' not in params) or (params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `get_discussions`")
        # verify the required parameter 'end' is set
        if ('end' not in params) or (params['end'] is None):
            raise ValueError("Missing the required parameter `end` when calling `get_discussions`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `get_discussions`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `get_discussions`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `get_discussions`")


        collection_formats = {}

        resource_path = '/collaborations/discussions'.replace('{format}', 'json')
        path_params = {}

        query_params = {}
        if 'organization_id' in params:
            query_params['organizationId'] = params['organization_id']
        if 'start' in params:
            query_params['start'] = params['start']
        if 'end' in params:
            query_params['end'] = params['end']
        if 'fields' in params:
            query_params['fields'] = params['fields']

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseDiscussionList',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_user_subscribed_blogs(self, user_id, start, end, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Get list of blogs subscribed by user
        Returns the list of blogs subscribed by user
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_subscribed_blogs(user_id, start, end, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: userId (required)
        :param int start: start, initial value start from 0 (required)
        :param int end: end (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :param str fields: Filter fields in result list<br/> <b>A) Default values -</b> <br/>1)blogId<br/>2)blogTitle<br/>3)blogDescription<br/>4)createdDate<br/><b>A )Available values-</b><br/>1)blogId<br/>2)blogTitle<br/>3)blogDescription<br/>4)createdDate<br/>5)user<br/>6)sentiment</br>7)entity
        :return: VerveResponseBlog
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_user_subscribed_blogs_with_http_info(user_id, start, end, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.get_user_subscribed_blogs_with_http_info(user_id, start, end, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def get_user_subscribed_blogs_with_http_info(self, user_id, start, end, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Get list of blogs subscribed by user
        Returns the list of blogs subscribed by user
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_subscribed_blogs_with_http_info(user_id, start, end, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: userId (required)
        :param int start: start, initial value start from 0 (required)
        :param int end: end (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :param str fields: Filter fields in result list<br/> <b>A) Default values -</b> <br/>1)blogId<br/>2)blogTitle<br/>3)blogDescription<br/>4)createdDate<br/><b>A )Available values-</b><br/>1)blogId<br/>2)blogTitle<br/>3)blogDescription<br/>4)createdDate<br/>5)user<br/>6)sentiment</br>7)entity
        :return: VerveResponseBlog
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'start', 'end', 'logged_in_user_id', 'access_token', 'client_token', 'fields']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_subscribed_blogs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_user_subscribed_blogs`")
        # verify the required parameter 'start' is set
        if ('start' not in params) or (params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `get_user_subscribed_blogs`")
        # verify the required parameter 'end' is set
        if ('end' not in params) or (params['end'] is None):
            raise ValueError("Missing the required parameter `end` when calling `get_user_subscribed_blogs`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `get_user_subscribed_blogs`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `get_user_subscribed_blogs`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `get_user_subscribed_blogs`")


        collection_formats = {}

        resource_path = '/collaborations/blogs/{userId}/subscribe'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']

        query_params = {}
        if 'start' in params:
            query_params['start'] = params['start']
        if 'end' in params:
            query_params['end'] = params['end']
        if 'fields' in params:
            query_params['fields'] = params['fields']

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseBlog',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def get_user_subscribed_discussions(self, user_id, start, end, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Get list of discussions subscribed by user
        Returns the list of discussions subscribed by user 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_subscribed_discussions(user_id, start, end, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: userId (required)
        :param int start: start, initial value start from 0 (required)
        :param int end: end (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :param str fields: Filter fields in result list<br/> <b>A) Default values -</b> <br/>1)discussionId<br/>2)discussionSubject<br/>3)discussionDescription<br/>4)createdDate<br/><b>A) Available values-</b><br/>1)discussionId<br/>2)discussionSubject<br/>3)discussionDescription<br/>4)createdDate<br/>5)user<br/>6)sentiment</br>7)entity
        :return: VerveResponseDiscussionList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.get_user_subscribed_discussions_with_http_info(user_id, start, end, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.get_user_subscribed_discussions_with_http_info(user_id, start, end, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def get_user_subscribed_discussions_with_http_info(self, user_id, start, end, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Get list of discussions subscribed by user
        Returns the list of discussions subscribed by user 
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.get_user_subscribed_discussions_with_http_info(user_id, start, end, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int user_id: userId (required)
        :param int start: start, initial value start from 0 (required)
        :param int end: end (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :param str fields: Filter fields in result list<br/> <b>A) Default values -</b> <br/>1)discussionId<br/>2)discussionSubject<br/>3)discussionDescription<br/>4)createdDate<br/><b>A) Available values-</b><br/>1)discussionId<br/>2)discussionSubject<br/>3)discussionDescription<br/>4)createdDate<br/>5)user<br/>6)sentiment</br>7)entity
        :return: VerveResponseDiscussionList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'start', 'end', 'logged_in_user_id', 'access_token', 'client_token', 'fields']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_subscribed_discussions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params) or (params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_user_subscribed_discussions`")
        # verify the required parameter 'start' is set
        if ('start' not in params) or (params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `get_user_subscribed_discussions`")
        # verify the required parameter 'end' is set
        if ('end' not in params) or (params['end'] is None):
            raise ValueError("Missing the required parameter `end` when calling `get_user_subscribed_discussions`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `get_user_subscribed_discussions`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `get_user_subscribed_discussions`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `get_user_subscribed_discussions`")


        collection_formats = {}

        resource_path = '/collaborations/discussions/{userId}/subscribe'.replace('{format}', 'json')
        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']

        query_params = {}
        if 'start' in params:
            query_params['start'] = params['start']
        if 'end' in params:
            query_params['end'] = params['end']
        if 'fields' in params:
            query_params['fields'] = params['fields']

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseDiscussionList',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def post_blog(self, organization_id, blog_title, blog_description, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Post blog
        Allows the user to post a blog. Returns the posted blog
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_blog(organization_id, blog_title, blog_description, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int organization_id: organizationId (required)
        :param str blog_title: blogTitle (required)
        :param str blog_description: blogDescription (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseBlog
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.post_blog_with_http_info(organization_id, blog_title, blog_description, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.post_blog_with_http_info(organization_id, blog_title, blog_description, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def post_blog_with_http_info(self, organization_id, blog_title, blog_description, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Post blog
        Allows the user to post a blog. Returns the posted blog
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.post_blog_with_http_info(organization_id, blog_title, blog_description, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int organization_id: organizationId (required)
        :param str blog_title: blogTitle (required)
        :param str blog_description: blogDescription (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseBlog
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'blog_title', 'blog_description', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_blog" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `post_blog`")
        # verify the required parameter 'blog_title' is set
        if ('blog_title' not in params) or (params['blog_title'] is None):
            raise ValueError("Missing the required parameter `blog_title` when calling `post_blog`")
        # verify the required parameter 'blog_description' is set
        if ('blog_description' not in params) or (params['blog_description'] is None):
            raise ValueError("Missing the required parameter `blog_description` when calling `post_blog`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `post_blog`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `post_blog`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `post_blog`")


        collection_formats = {}

        resource_path = '/collaborations/blogs'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}
        if 'organization_id' in params:
            form_params.append(('organizationId', params['organization_id']))
        if 'blog_title' in params:
            form_params.append(('blogTitle', params['blog_title']))
        if 'blog_description' in params:
            form_params.append(('blogDescription', params['blog_description']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/x-www-form-urlencoded'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseBlog',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def start_discussion(self, organization_id, subject, description, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Start discussion
        Allows the user to start discussion. Returns the started discussion
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.start_discussion(organization_id, subject, description, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int organization_id: organizationId (required)
        :param str subject: subject (required)
        :param str description: description (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseDiscussion
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.start_discussion_with_http_info(organization_id, subject, description, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.start_discussion_with_http_info(organization_id, subject, description, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def start_discussion_with_http_info(self, organization_id, subject, description, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Start discussion
        Allows the user to start discussion. Returns the started discussion
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.start_discussion_with_http_info(organization_id, subject, description, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int organization_id: organizationId (required)
        :param str subject: subject (required)
        :param str description: description (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseDiscussion
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'subject', 'description', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_discussion" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params) or (params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `start_discussion`")
        # verify the required parameter 'subject' is set
        if ('subject' not in params) or (params['subject'] is None):
            raise ValueError("Missing the required parameter `subject` when calling `start_discussion`")
        # verify the required parameter 'description' is set
        if ('description' not in params) or (params['description'] is None):
            raise ValueError("Missing the required parameter `description` when calling `start_discussion`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `start_discussion`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `start_discussion`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `start_discussion`")


        collection_formats = {}

        resource_path = '/collaborations/discussions'.replace('{format}', 'json')
        path_params = {}

        query_params = {}

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}
        if 'organization_id' in params:
            form_params.append(('organizationId', params['organization_id']))
        if 'subject' in params:
            form_params.append(('subject', params['subject']))
        if 'description' in params:
            form_params.append(('description', params['description']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/x-www-form-urlencoded'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseDiscussion',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def subscribe_blog(self, blog_id, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Subscribe blog
        Allows the user to subscribe to blog. Returns the subscribed blog
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.subscribe_blog(blog_id, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int blog_id: blogId (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseBlog
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.subscribe_blog_with_http_info(blog_id, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.subscribe_blog_with_http_info(blog_id, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def subscribe_blog_with_http_info(self, blog_id, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Subscribe blog
        Allows the user to subscribe to blog. Returns the subscribed blog
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.subscribe_blog_with_http_info(blog_id, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int blog_id: blogId (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseBlog
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['blog_id', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method subscribe_blog" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'blog_id' is set
        if ('blog_id' not in params) or (params['blog_id'] is None):
            raise ValueError("Missing the required parameter `blog_id` when calling `subscribe_blog`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `subscribe_blog`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `subscribe_blog`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `subscribe_blog`")


        collection_formats = {}

        resource_path = '/collaborations/blogs/{blogId}/subscribe'.replace('{format}', 'json')
        path_params = {}
        if 'blog_id' in params:
            path_params['blogId'] = params['blog_id']

        query_params = {}

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/x-www-form-urlencoded'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseBlog',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def subscribe_discussion(self, discussion_id, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Subscribe discussion
        Allows the user to subscribe to a discussion. Returns the subscribed discussion
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.subscribe_discussion(discussion_id, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int discussion_id: discussionId (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseDiscussion
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.subscribe_discussion_with_http_info(discussion_id, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.subscribe_discussion_with_http_info(discussion_id, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def subscribe_discussion_with_http_info(self, discussion_id, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Subscribe discussion
        Allows the user to subscribe to a discussion. Returns the subscribed discussion
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.subscribe_discussion_with_http_info(discussion_id, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int discussion_id: discussionId (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseDiscussion
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['discussion_id', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method subscribe_discussion" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'discussion_id' is set
        if ('discussion_id' not in params) or (params['discussion_id'] is None):
            raise ValueError("Missing the required parameter `discussion_id` when calling `subscribe_discussion`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `subscribe_discussion`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `subscribe_discussion`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `subscribe_discussion`")


        collection_formats = {}

        resource_path = '/collaborations/discussions/{discussionId}/subscribe'.replace('{format}', 'json')
        path_params = {}
        if 'discussion_id' in params:
            path_params['discussionId'] = params['discussion_id']

        query_params = {}

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/x-www-form-urlencoded'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseDiscussion',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def unsubscribe_blog(self, blog_id, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Unsubscribe blog
        Allows the user to unsubscribe blog. Returns the unsubscribed blog
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.unsubscribe_blog(blog_id, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int blog_id: blogId (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseBlog
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.unsubscribe_blog_with_http_info(blog_id, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.unsubscribe_blog_with_http_info(blog_id, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def unsubscribe_blog_with_http_info(self, blog_id, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Unsubscribe blog
        Allows the user to unsubscribe blog. Returns the unsubscribed blog
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.unsubscribe_blog_with_http_info(blog_id, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int blog_id: blogId (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseBlog
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['blog_id', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unsubscribe_blog" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'blog_id' is set
        if ('blog_id' not in params) or (params['blog_id'] is None):
            raise ValueError("Missing the required parameter `blog_id` when calling `unsubscribe_blog`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `unsubscribe_blog`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `unsubscribe_blog`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `unsubscribe_blog`")


        collection_formats = {}

        resource_path = '/collaborations/blogs/{blogId}/unsubscribe'.replace('{format}', 'json')
        path_params = {}
        if 'blog_id' in params:
            path_params['blogId'] = params['blog_id']

        query_params = {}

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/x-www-form-urlencoded'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseBlog',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def unsubscribe_discussion(self, discussion_id, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Unsubscribe discussion
        Allows the user to unsubscribe to a discussion. Returns the unsubscribed discussion
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.unsubscribe_discussion(discussion_id, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int discussion_id: discussionId (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseDiscussion
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.unsubscribe_discussion_with_http_info(discussion_id, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.unsubscribe_discussion_with_http_info(discussion_id, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def unsubscribe_discussion_with_http_info(self, discussion_id, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Unsubscribe discussion
        Allows the user to unsubscribe to a discussion. Returns the unsubscribed discussion
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.unsubscribe_discussion_with_http_info(discussion_id, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int discussion_id: discussionId (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseDiscussion
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['discussion_id', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unsubscribe_discussion" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'discussion_id' is set
        if ('discussion_id' not in params) or (params['discussion_id'] is None):
            raise ValueError("Missing the required parameter `discussion_id` when calling `unsubscribe_discussion`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `unsubscribe_discussion`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `unsubscribe_discussion`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `unsubscribe_discussion`")


        collection_formats = {}

        resource_path = '/collaborations/discussions/{discussionId}/unsubscribe'.replace('{format}', 'json')
        path_params = {}
        if 'discussion_id' in params:
            path_params['discussionId'] = params['discussion_id']

        query_params = {}

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/x-www-form-urlencoded'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseDiscussion',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_blog(self, blog_id, blog_title, blog_description, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Update blog
        Allows the user to update blog. Returns the updated blog
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_blog(blog_id, blog_title, blog_description, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int blog_id: blogId (required)
        :param str blog_title: blog title (required)
        :param str blog_description: blog description (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseBlog
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_blog_with_http_info(blog_id, blog_title, blog_description, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.update_blog_with_http_info(blog_id, blog_title, blog_description, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def update_blog_with_http_info(self, blog_id, blog_title, blog_description, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Update blog
        Allows the user to update blog. Returns the updated blog
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_blog_with_http_info(blog_id, blog_title, blog_description, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int blog_id: blogId (required)
        :param str blog_title: blog title (required)
        :param str blog_description: blog description (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseBlog
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['blog_id', 'blog_title', 'blog_description', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_blog" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'blog_id' is set
        if ('blog_id' not in params) or (params['blog_id'] is None):
            raise ValueError("Missing the required parameter `blog_id` when calling `update_blog`")
        # verify the required parameter 'blog_title' is set
        if ('blog_title' not in params) or (params['blog_title'] is None):
            raise ValueError("Missing the required parameter `blog_title` when calling `update_blog`")
        # verify the required parameter 'blog_description' is set
        if ('blog_description' not in params) or (params['blog_description'] is None):
            raise ValueError("Missing the required parameter `blog_description` when calling `update_blog`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `update_blog`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `update_blog`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `update_blog`")


        collection_formats = {}

        resource_path = '/collaborations/blogs/{blogId}'.replace('{format}', 'json')
        path_params = {}
        if 'blog_id' in params:
            path_params['blogId'] = params['blog_id']

        query_params = {}

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}
        if 'blog_title' in params:
            form_params.append(('blogTitle', params['blog_title']))
        if 'blog_description' in params:
            form_params.append(('blogDescription', params['blog_description']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseBlog',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_blog_comment(self, comment_id, comment_text, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Update blog comment
        Allows the user to update blog comment. Returns the updated blog comment
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_blog_comment(comment_id, comment_text, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int comment_id: commentId (required)
        :param str comment_text: comment text (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseComment
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_blog_comment_with_http_info(comment_id, comment_text, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.update_blog_comment_with_http_info(comment_id, comment_text, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def update_blog_comment_with_http_info(self, comment_id, comment_text, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Update blog comment
        Allows the user to update blog comment. Returns the updated blog comment
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_blog_comment_with_http_info(comment_id, comment_text, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int comment_id: commentId (required)
        :param str comment_text: comment text (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseComment
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['comment_id', 'comment_text', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_blog_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'comment_id' is set
        if ('comment_id' not in params) or (params['comment_id'] is None):
            raise ValueError("Missing the required parameter `comment_id` when calling `update_blog_comment`")
        # verify the required parameter 'comment_text' is set
        if ('comment_text' not in params) or (params['comment_text'] is None):
            raise ValueError("Missing the required parameter `comment_text` when calling `update_blog_comment`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `update_blog_comment`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `update_blog_comment`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `update_blog_comment`")


        collection_formats = {}

        resource_path = '/collaborations/blogs/comments/{commentId}'.replace('{format}', 'json')
        path_params = {}
        if 'comment_id' in params:
            path_params['commentId'] = params['comment_id']

        query_params = {}

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}
        if 'comment_text' in params:
            form_params.append(('commentText', params['comment_text']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseComment',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_discussion(self, discussion_id, subject, discussion_description, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Update discussion
        Allows the user to update discussion. Returns the updated discussion
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_discussion(discussion_id, subject, discussion_description, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int discussion_id: discussionId (required)
        :param str subject: subject (required)
        :param str discussion_description: discussion Description (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseDiscussion
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_discussion_with_http_info(discussion_id, subject, discussion_description, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.update_discussion_with_http_info(discussion_id, subject, discussion_description, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def update_discussion_with_http_info(self, discussion_id, subject, discussion_description, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Update discussion
        Allows the user to update discussion. Returns the updated discussion
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_discussion_with_http_info(discussion_id, subject, discussion_description, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int discussion_id: discussionId (required)
        :param str subject: subject (required)
        :param str discussion_description: discussion Description (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseDiscussion
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['discussion_id', 'subject', 'discussion_description', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_discussion" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'discussion_id' is set
        if ('discussion_id' not in params) or (params['discussion_id'] is None):
            raise ValueError("Missing the required parameter `discussion_id` when calling `update_discussion`")
        # verify the required parameter 'subject' is set
        if ('subject' not in params) or (params['subject'] is None):
            raise ValueError("Missing the required parameter `subject` when calling `update_discussion`")
        # verify the required parameter 'discussion_description' is set
        if ('discussion_description' not in params) or (params['discussion_description'] is None):
            raise ValueError("Missing the required parameter `discussion_description` when calling `update_discussion`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `update_discussion`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `update_discussion`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `update_discussion`")


        collection_formats = {}

        resource_path = '/collaborations/discussions/{discussionId}'.replace('{format}', 'json')
        path_params = {}
        if 'discussion_id' in params:
            path_params['discussionId'] = params['discussion_id']

        query_params = {}

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}
        if 'subject' in params:
            form_params.append(('subject', params['subject']))
        if 'discussion_description' in params:
            form_params.append(('discussionDescription', params['discussion_description']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseDiscussion',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def update_discussion_comment(self, comment_id, comment_text, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Update discussion comment
        Allows the user to update discussion comment. Returns the updated discussion comment
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_discussion_comment(comment_id, comment_text, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int comment_id: commentId (required)
        :param str comment_text: comment text (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseDiscussion
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.update_discussion_comment_with_http_info(comment_id, comment_text, logged_in_user_id, access_token, client_token, **kwargs)
        else:
            (data) = self.update_discussion_comment_with_http_info(comment_id, comment_text, logged_in_user_id, access_token, client_token, **kwargs)
            return data

    def update_discussion_comment_with_http_info(self, comment_id, comment_text, logged_in_user_id, access_token, client_token, **kwargs):
        """
        Update discussion comment
        Allows the user to update discussion comment. Returns the updated discussion comment
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.update_discussion_comment_with_http_info(comment_id, comment_text, logged_in_user_id, access_token, client_token, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param int comment_id: commentId (required)
        :param str comment_text: comment text (required)
        :param str logged_in_user_id: User id of logged / authenticated user (required)
        :param str access_token: Unique session token for user. To get access token user will have to authenticate (required)
        :param str client_token: Use the Client Token. Please generate it from the Applications section under the Production & Sandbox tabs (required)
        :return: VerveResponseDiscussion
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['comment_id', 'comment_text', 'logged_in_user_id', 'access_token', 'client_token']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_discussion_comment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'comment_id' is set
        if ('comment_id' not in params) or (params['comment_id'] is None):
            raise ValueError("Missing the required parameter `comment_id` when calling `update_discussion_comment`")
        # verify the required parameter 'comment_text' is set
        if ('comment_text' not in params) or (params['comment_text'] is None):
            raise ValueError("Missing the required parameter `comment_text` when calling `update_discussion_comment`")
        # verify the required parameter 'logged_in_user_id' is set
        if ('logged_in_user_id' not in params) or (params['logged_in_user_id'] is None):
            raise ValueError("Missing the required parameter `logged_in_user_id` when calling `update_discussion_comment`")
        # verify the required parameter 'access_token' is set
        if ('access_token' not in params) or (params['access_token'] is None):
            raise ValueError("Missing the required parameter `access_token` when calling `update_discussion_comment`")
        # verify the required parameter 'client_token' is set
        if ('client_token' not in params) or (params['client_token'] is None):
            raise ValueError("Missing the required parameter `client_token` when calling `update_discussion_comment`")


        collection_formats = {}

        resource_path = '/collaborations/discussions/comments/{commentId}'.replace('{format}', 'json')
        path_params = {}
        if 'comment_id' in params:
            path_params['commentId'] = params['comment_id']

        query_params = {}

        header_params = {}
        if 'logged_in_user_id' in params:
            header_params['loggedInUserId'] = params['logged_in_user_id']
        if 'access_token' in params:
            header_params['accessToken'] = params['access_token']
        if 'client_token' in params:
            header_params['clientToken'] = params['client_token']

        form_params = []
        local_var_files = {}
        if 'comment_text' in params:
            form_params.append(('commentText', params['comment_text']))

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.\
            select_header_accept(['application/json', 'application/xml'])

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.\
            select_header_content_type(['application/json', 'application/x-www-form-urlencoded'])

        # Authentication setting
        auth_settings = ['default']

        return self.api_client.call_api(resource_path, 'PUT',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='VerveResponseDiscussion',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
